bytes文件：包含原文件16进制码
asm文件：bytes文件经过反编译得到
asm文件直接可用特征：opcode, operand
asm文件可提取特征：cfg

注意：都是静态特征，动态特征？api call graph？（缺乏可用数据集和标签）

1. 直接根据bytes文件分类？
转成图像，用CNN分类！

2. 需要保留哪些信息？
先去学学awk吧...

3. 根据从asm文件分类？
nlp方法

4. 要哪些字段？
opcode！ operand呢？好像也可以要！

5. 还有什么特征？
cfg！怎么说，可以通过IDA pro提取cfg，这部分特征是CNN和RNN难以提取的特征！

6. 怎么做？
GCN [看我](https://www.researchgate.net/publication/340973764_Graph_Convolutional_Networks_for_Android_Malware_Detection_with_System_Call_Graphs)

7. 啊啊啊，没特征可用了...那模型？
CNN? RNN? Attention? 
CNN? 用图像搞玄学
RNN？opcode是一段极长的序列，真的不需要句子吗？API call sequence？有戏，异常序列检测？
Attention？有什么意义呢，证明Attention效果比RNN好？
当我们使用一个模型时，故意选择这个模型是希望他学到这个信息，比如CNN提取局部关联信息，RNN提取依赖信息，Attention提取结构信息
深度学习是为了提取玄学特征!
这部分不是很擅长啊，不过反正是个占坑的艺术，抢不过，抢不过...

8. so？还是动态特征？
没数据集，造数据集！已有APT组织数据集，virusshare数据集，都包含可执行文件，可以用来？做恶意代码检测！分类缺乏标签，检测可以直接下载正常可执行文件

9. 没啥新意？做GCN+GAN生成恶意代码？
貌似可以！有搞头！

10. 还是先把bytes文件转化为bmp吧
搞定

11. 如何得到可执行文件的bytes文件?
取text段？kaggle提取了.text, .data, .rdata, .idata(collapsed), .edata(collapsed)，.rsrc(collapsed)其中idata和edata被IDA折叠了，可以删去这部分信息,
asm也包含这些段,

>
.idata: holds the import directory, optional, can be viewed as import {...}
.edata: holds the export directory, optional, can be viewed as export {...} 
.rsrc: holds the resource directory, optional

bytes文件中??表示这部分空间并非属于.data,.rdata,idata，而是未定义的空间（没有被使用），因此值是未定义的，因此这部分信息也可以删去,


12. 关于函数和栈内寻址
对于函数，有bp-based frame，即使用bp寻址栈内变量，也有sp-based frame，即使用sp寻址栈内变量

IDA是根据retn识别和划分函数的, retn会跳转到caller的位置


13. 有不有不玄学的方法？
asm -> cfg ->(hard!) 语义化的执行阶段 ->(玄学) 目的
单个函数调用往往是没意义的，但一堆函数调用可能具有明显意义，
cfg是特殊的图，有向拓扑图，沙箱分析只能得到单一执行路径
如何对图进行遍历，获取某条分支上的语义化信息，begin（proc1, proc2, ...）if（(cond1, proc1), (cond2, proc2)...) ，回路...
这种聚合后的语义化信息可能是make sense的


14. 模型其实可以做成热插拔的形式？
原始数据 -> (...) -> class/prediction
原始数据 -> bitmap/opcode/... -> convert -> model -> prediction
但这有什么意义呢？
不同模型可能从不同角度对原始数据进行分类，依靠不同的模型分析，可以得到更综合的结果
和bagging, stacking的区别？
可以尝试一下，但区别还是有的

15. 谜底就在谜面上，人是怎么识别恶意代码的？
GCN, HMM?解释性很棒，但是计算能力太低

