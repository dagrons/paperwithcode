# %%
import torch
import torch.nn.functional as F
from PIL import Image
import numpy as np
import tempfile
from resnet import *  
 
# %%
import os
import sys
module_path = os.path.abspath(os.path.join('.'))
if module_path not in sys.path:
    sys.path.append(module_path)

# %%
from scripts.tranform import * 

# %%
# 加载模型字典
model_state_dict_path = "/root/paperwithcode/第三周-训练篇/malware_classifcation/trained_models/malware_classification%resnet34%best.pt" # 要使用的模型字典地址
model_state_dict = torch.load(model_state_dict_path)
model = ResNet(num_block=[3, 4, 6, 3]).cuda()
model.load_state_dict(model_state_dict)
model.eval()

# %%
def predict(data_or_path, mode='bmp'): # support bmp, pe, bytes, raw types
    try: 
        if mode == "bmp":
            img = Image.open(data_or_path)
            img = img.resize((64, 64))
            img_mat = np.asarray(img, dtype=np.float32)
            img_mat = np.reshape(img_mat, (1, 64, 64))
            img_mat = np.repeat(img_mat, 3, axis=0)
            img_mat = torch.from_numpy(img_mat)
            img_mat = torch.unsqueeze(img_mat, axis=0).cuda()
            y_pred = model(img_mat)
            return [t.item() for t in F.softmax(y_pred, 1)[0]]
        if mode == "pe":
            _, bmp_path = tempfile.mkstemp(suffix='.bmp')
            pe2bmp(data_or_path, bmp_path)
            return predict(bmp_path, mode='bmp')
        if mode == "bytes":
            _, bmp_path = tempfile.mkstemp(suffix='.bmp')
            bytes2bmp(data_or_path, bmp_path)
            return predict(bmp_path, mode='bmp')
        else: # mode == "raw torch tensor 3x64x64"
            y_pred = model(data_or_path)
            return [t.item() for t in F.softmax(y_pred, 1)[0]]
    except:
        pass
    return [1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1] # 用于表示缺省值，上述代码中，进行格式转换时可能会出现异常，所以缺省值是必要的

